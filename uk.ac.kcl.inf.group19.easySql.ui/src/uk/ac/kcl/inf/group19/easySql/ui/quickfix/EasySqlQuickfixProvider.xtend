/*
 * generated by Xtext 2.26.0
 */
package uk.ac.kcl.inf.group19.easySql.ui.quickfix

import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import uk.ac.kcl.inf.group19.easySql.validation.EasySqlValidator
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.validation.Issue
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import uk.ac.kcl.inf.group19.easySql.easySql.TableDeclaration
import java.util.Random
import java.util.random.RandomGeneratorFactory
import java.util.random.RandomGenerator
import uk.ac.kcl.inf.group19.easySql.easySql.JoinQuery
import java.util.List

/**
 * Custom quickfixes.
 *
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
class EasySqlQuickfixProvider extends DefaultQuickfixProvider {

	@Fix(EasySqlValidator.INVALID_CASE_TABLE_NAME)
	def LowerCaseTableName(Issue issue, IssueResolutionAcceptor acceptor) 
	{
		acceptor.acceptMulti(issue,'Automatically convert to lower-case version','Change the table name into a lower-case version',null)[element | 
			val tableName =element as TableDeclaration
			tableName.name =tableName.name.toLowerCase
		]
	}	
	
	@Fix(EasySqlValidator.INVALID_KEY_TABLE_NAME )
	def ModifyingKeyToTableName(Issue issue, IssueResolutionAcceptor acceptor) 
	{
		acceptor.acceptMulti(issue,"Add character 'a' to the beginning","Change the key name into another new name that is not a key word by adding character 'a' to the beginning ",null)[element |
			val tableName =element as TableDeclaration
			var newTableName = tableName.name			
			tableName.name= 'a_'+newTableName
		]
		
		acceptor.acceptMulti(issue,"Delete the top character(choose only when the length of table's name >1 !)",'Shorten the key name into another new name that is not a key word by deleting the top character ',null)[element |
			val tableName1 =element as TableDeclaration
			var newTableName1 = tableName1.name			
		    tableName1.name =newTableName1.substring(1)			
	   ]
	   
	   acceptor.acceptMulti(issue,"replace the top character with a random character !)",'Shorten the key name into another new name that is not a key word by replacing the top character with a random character ',null)[element |
			val tableName2 =element as TableDeclaration
			var newTableName2 = tableName2.name			
		    if(!newTableName2.charAt(0).equals('a'))
		        tableName2.name = 'a'+newTableName2.substring(1)
		    else 
		        tableName2.name = 'b'+newTableName2.substring(1)		
	   ]
	}

    @Fix(EasySqlValidator.INVALID_DUPLICATE_TABLE_NAME )
	def ModifyingDuplicateToTableName(Issue issue, IssueResolutionAcceptor acceptor) 
	{
		acceptor.accept(issue,"Add characters 'an' to the beginning","Change the key name into another new name that is not a key word by adding characters 'an' to the beginning ",null)[context |
			val xtextDocument = context.xtextDocument
			val duplicateTableName = xtextDocument.get(issue.offset,issue.length)
			xtextDocument.replace(issue.offset,issue.length,'an_'+duplicateTableName)
			
		]
		
		acceptor.accept(issue,"Delete the final character(choose only when the length of table's name >1 !)",'Shorten the key name into another new name that is not a key word by deleting the final character ',null)[context |
			val xtextDocument = context.xtextDocument
			val duplicateTableName = xtextDocument.get(issue.offset,issue.length)
			xtextDocument.replace(issue.offset,issue.length,duplicateTableName.substring(0,(duplicateTableName.length-1)))	
			
		]
		
		acceptor.accept(issue,"replace the final character with a random character !)",'Shorten the key name into another new name that is not a key word by replacing the final character with a random character ',null)[context |
			val xtextDocument = context.xtextDocument
			val duplicateTableName = xtextDocument.get(issue.offset,issue.length)
			
			if(!duplicateTableName.charAt(duplicateTableName.length-1).equals('a'))
			   xtextDocument.replace(issue.offset,issue.length,(duplicateTableName.substring(0,duplicateTableName.length-1))+'a')	
			else 
			   xtextDocument.replace(issue.offset,issue.length,(duplicateTableName.substring(0,duplicateTableName.length-1))+'b')
		]
		
	}
    
    //the table name is too long, cut into a shorter one
    @Fix(EasySqlValidator.INVALID_TOOLONG_TABLE_NAME)
    def CutTableName(Issue issue, IssueResolutionAcceptor acceptor)
    {
    	acceptor.acceptMulti(issue,"Cut off the final part of the table name a little!","The table name is too long! Cutting a small piece of the final part will help a lot! ",null)[element |
			val tableName =element as TableDeclaration
			var newTableName = tableName.name			
			tableName.name= newTableName.substring(0,14)
		]
    }
    
    
    //the table name of a attribute  in a join sentence should be either from table1 or table2
    @Fix(EasySqlValidator.INVALID_ATTRIBUTE_JOIN_TABLE)
    def UnifyAttributeInJoinTables(Issue issue, IssueResolutionAcceptor acceptor)
    {
    	acceptor.accept(issue,"change the table name in the wrong attribute into the corresponding one !)",
    	' change the table name into one of the two tables joined together ',null)[context |
    	
    	    var xtextDocument = context.xtextDocument  //get all content 
    		var theLineOfTheIssue = issue.lineNumber   //get the line number where the issue exists
    		var theLineInformation = xtextDocument.getLineInformation(theLineOfTheIssue) //get that line's information, its size and this line's final character's idnex	
    		
    		//the index of the first character in the line
    		var theFirstIndexOfCharacterInThisLine = xtextDocument.getLineInformation(theLineOfTheIssue).offset - xtextDocument.getLineInformation(theLineOfTheIssue).length
    		var theLengthOfTheLine = xtextDocument.getLineInformation(theLineOfTheIssue).length
    		
    		//the value of the variable "theFirstIndexOfCharacterInThisLine" is wrong, need modification
    		while(Character.isLetter((xtextDocument.get(theFirstIndexOfCharacterInThisLine-1,1)).charAt(0))) 
    		{
    			theFirstIndexOfCharacterInThisLine--
    		}
    		
    		//get all content in that line, which is a Join query sentence where the issue happened
    		var originalJoinQuery =  xtextDocument.get(theFirstIndexOfCharacterInThisLine,theLengthOfTheLine).replace('\n','').replace('\r','')
    		

    		//Get Jtable1
    		var JoinQuery = originalJoinQuery
			var endPositionOfJtable1 =JoinQuery.indexOf('.')
			var Jtable1 =JoinQuery.substring(0,endPositionOfJtable1)
			var indicator =0
			//Get Jtable2		
			var startPositionOfJtable2 = 0  //judge if it is a left/right/full/inner join type
		    var JoinQuery1 = originalJoinQuery			
			if(JoinQuery1.indexOf('right_join')!=-1) // means it is a right-join type
			    startPositionOfJtable2 =JoinQuery1.indexOf('right_join')+11
		    if(JoinQuery1.indexOf('left_join')!=-1)    //means it is a left-join type
			    startPositionOfJtable2 =JoinQuery1.indexOf('left_join')+10
			if(JoinQuery1.indexOf('full_join')!=-1)        //means it is a full-join type
			    startPositionOfJtable2 =JoinQuery1.indexOf('full_join')+10
			if(JoinQuery1.indexOf('inner_join')!=-1) 
			    {
			    	 startPositionOfJtable2 =JoinQuery1.indexOf('inner_join')+11   //means it is a inner-join type
			    }
			   
			     
			
			var endPositionOfJtable2 = JoinQuery1.indexOf(').On')   //this is a fixed index
			var Jtable2 =JoinQuery.substring(startPositionOfJtable2,endPositionOfJtable2)    //Get Jtable2 
			
			var copy1 = originalJoinQuery
			var start = copy1.indexOf('(')+1
			var end = copy1.indexOf(')')
			var allAttributeLength =end-start
			var originalAllAttribute =copy1.substring(start,end)  //storing all elements in Jattributes of a join-query in a form of 'table.attribute'
			var List<String> list =originalAllAttribute.replace(' ','').split(',') //every element in the list is in a form of table.attribute
			
			var newAllAttribute =''
						
			
			for(var i=0;i<list.size;i++)
			{
				var a = list.get(i)
				a=a.substring(0,a.indexOf('-')) //for each element, retrieve the table part from the table.attribute type element
				if(!a.equals(Jtable1)&&!a.equals(Jtable2))//if that table is neither Jtable1 nor Jtable2
				   {
				    //a=Jtable1+list.get(i).substring(list.get(i).indexOf('-'))   //modify the table.attribute into Jtable1.attribute -----Choice1
				   	a=Jtable2+list.get(i).substring(list.get(i).indexOf('-'))  //modify the table.attribute into Jtable2.attribute ------Choice2
				   	newAllAttribute=newAllAttribute+a+','
				   }
				else
				{
					newAllAttribute=newAllAttribute+list.get(i)+','   // if the table.attribute is correct, keep it
				}
			}
			
			newAllAttribute=newAllAttribute.substring(0,(newAllAttribute.length-1))   //cut the final "," symbol
			
			//xtextDocument.replace(issue.offset,allAttributeLength,newAllAttribute+"Jtable1 is "+Jtable1 +" and Jtable2 is "+Jtable2+" ||and  "+originalJoinQuery)
              xtextDocument.replace(issue.offset,allAttributeLength,newAllAttribute)   	
    	]
    }
    
    }
