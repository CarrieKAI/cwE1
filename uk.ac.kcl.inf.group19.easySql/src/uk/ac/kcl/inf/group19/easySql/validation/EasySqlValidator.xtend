/*
 * generated by Xtext 2.26.0
 */
package uk.ac.kcl.inf.group19.easySql.validation

import org.eclipse.xtext.validation.Check
import uk.ac.kcl.inf.group19.easySql.easySql.EasySqlPackage
import uk.ac.kcl.inf.group19.easySql.easySql.TableDeclaration
import java.util.List
import uk.ac.kcl.inf.group19.easySql.easySql.SqlProgram
import org.eclipse.emf.ecore.EObject
import uk.ac.kcl.inf.group19.easySql.easySql.JoinQuery
import uk.ac.kcl.inf.group19.easySql.easySql.Delete
import java.util.Iterator
import uk.ac.kcl.inf.group19.easySql.easySql.Equation
import uk.ac.kcl.inf.group19.easySql.easySql.Update
import uk.ac.kcl.inf.group19.easySql.easySql.NestedQuery

/** 
 * This class contains custom validation rules. 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EasySqlValidator extends AbstractEasySqlValidator {

	public static val INVALID_CASE_TABLE_NAME = "uk.ac.kcl.inf.group19.easySql.INVALID_TABLE_NAME_CASE_PROBLEM"
	public static val INVALID_KEY_TABLE_NAME = 'uk.ac.kcl.inf.group19.easySql.TABLE_NAME_KEY_PROBLEM'
    public static val INVALID_DUPLICATE_TABLE_NAME = 'uk.ac.kcl.inf.group19.easySql.TABLE_NAME_DUPLICATE_PROBLEM'
    public static val INVALID_TOOLONG_TABLE_NAME = 'uk.ac.kcl.inf.group19.easySql.TABLE_NAME_TOOLONG_PROBLEM'
	
	public static val INVALID_ATTRIBUTE_JOIN_TABLE = 'uk.ac.kcl.inf.group19.easySql.JOIN_TABLE_ATTRIBUTE_PROBLEM'
	public static val INVALID_CONDITION_JOIN_TABLE = 'uk.ac.kcl.inf.group19.easySql.JOIN_TABLE_CONDITION_PROBLEM'
	public static val INVALID_TABLE_DUPLICATION_JOIN_TABLE = 'uk.ac.kcl.inf.group19.easySql.JOIN_TABLE_DUPLICATION_TABLENAME_PROBLEM'
	public static val INVALID_TABLE_JOIN_TABLE = 'uk.ac.kcl.inf.group19.easySql.JOIN_TABLE_TABLE_PROBLEM'
	public static val INVALID_ATTRIBUTE_NOTNULL_JOIN_TABLE = 'uk.ac.kcl.inf.group19.easySql.JOIN_TABLE_ATTRIBUTE_NULL_PROBLEM'
	public static val INVALID_CONDITION_NOTNULL_JOIN_TABLE = 'uk.ac.kcl.inf.group19.easySql.JOIN_TABLE_CONDITION_NULL_PROBLEM'
	
	public static val INVALID_WHEN_NOTNULL_SUBSEARCH = 'uk.ac.kcl.inf.group19.easySql.SUBSEARCH_WHEN_NULL_PROBLEM'
	
	public static val INVALID_DUPLICATE_DELETE = 'uk.ac.kcl.inf.group19.easySql.DELETE_DUPLICATE_PROBLEM' 
	
	public static val INVALID_SETVALUE_NOTNULL_UNDATE ='uk.ac.kcl.inf.group19.easySql.UPDATE_EMPTYSET_PROBLEM' 
	
	
	//focus on checking the table declaration
	@Check(NORMAL)
	def void checkTableName(TableDeclaration tc) 
	{
		
		// 1. Check if the table name start With Upper-case Character
		var indicator =0
		for(var index=0;index<tc.name.length;index++)
		{
			if(Character.isUpperCase(tc.name.charAt(index)))
			{
			   indicator++
		    }
		}		        
        if(indicator!=0)
        warning("Table name should contain only Lower-case characters", tc,
				EasySqlPackage.Literals.TABLE_DECLARATION__NAME, INVALID_CASE_TABLE_NAME)


		//2. check table name is not key words
		var List<String> key = newArrayList('time','datetime','name','password','distinct','exists','limit','between')
		for(var index1=0; index1<key.length;index1++)
		{
			if(tc.name.equals(key.get(index1)))
			{
				warning('Invalid! Table name should not be a key word!',tc,
					EasySqlPackage.Literals.TABLE_DECLARATION__NAME, INVALID_KEY_TABLE_NAME
				)	
			}
		}

		//3. check if a table name is already existed or not
		var  List<String> allExistedTableName =tc.eContainer.eAllContents.filter(TableDeclaration).join(',').split(',')       
        //extract and store table name in the List 
        var loopSize =allExistedTableName.size        
        for(var index2=0; index2<loopSize;index2++)
        {
         allExistedTableName.set(index2,cutting(allExistedTableName.get(index2)))
        }
      
        var List<String> allRepeatTableName = getAllRepeatElements(allExistedTableName)
           
        if(allRepeatTableName.contains(tc.name))
         {
         	warning('Invalid! The table '+tc.name+" is already existed",tc,
         		EasySqlPackage.Literals.TABLE_DECLARATION__NAME, INVALID_DUPLICATE_TABLE_NAME
         	)
         }
            

     
     //4. Limit the length of the table name to be less than 15,table1ong
       var currentTableName = tc.name
       if(currentTableName.length>=15)
		  warning("this table's name <"+currentTableName+"> is too long!",tc,
         		EasySqlPackage.Literals.TABLE_DECLARATION__NAME, INVALID_TOOLONG_TABLE_NAME)

    }
    
    //focus on checking the problem of table-name consistency
    @Check(NORMAL)
    def checkJoinTableConsistency(JoinQuery jq)
   {  
   	  
   	  // 1.all table name from the Jattribute is either table1 or table2 or not
      var loopSize =jq.jattributes.size
          for(var i=0; i<loopSize;i++)
      {

          if(!jq.jattributes.get(i).table.name.equals(jq.jtable1.name) &&!jq.jattributes.get(i).table.name.equals(jq.jtable2.name))
            warning('Invalid! The table name <'+jq.jattributes.get(i).table.name+'> in the attributes should be either '+jq.jtable1.name+' or '+jq.jtable2.name,
          	jq,EasySqlPackage.Literals.JOIN_QUERY__JATTRIBUTES,INVALID_ATTRIBUTE_JOIN_TABLE)                    
       }
      
      //
       // 2.judge if all table name from the joincondition is either table1 or table2 or not
       var loopSize1 =jq.joincondition.size
       for(var i1=0; i1<loopSize1;i1++)
      {
      	  var indicator1 =0
          if(!jq.joincondition.get(i1).equationLeft.table.name.equals(jq.jtable1.name) &&!jq.joincondition.get(i1).equationLeft.table.name.equals(jq.jtable2.name) )
             indicator1++
                          
          else if(!jq.joincondition.get(i1).equationRight.table.name.equals(jq.jtable1.name) &&!jq.joincondition.get(i1).equationRight.table.name.equals(jq.jtable2.name) )
             indicator1++
                       
           if(indicator1 != 0)
          warning('Invalid! The table name in On() should be either from '+jq.jtable1.name+' or '+jq.jtable2.name,
          	jq,EasySqlPackage.Literals.JOIN_QUERY__JOINCONDITION,INVALID_CONDITION_JOIN_TABLE)           
       }
     
     //==================================================================================================================================
     // 3.Judge if Jtable1 = Jtable2, it is not allowed
      if(jq.jtable1.name.equals(jq.jtable2.name))
      {
      	warning('Invalid! A table cannot connect to itself!',
          	jq,EasySqlPackage.Literals.JOIN_QUERY__JTABLE1,INVALID_TABLE_DUPLICATION_JOIN_TABLE)  
      }
              
   }
	
	//focus on checking delete operation
	@Check
	def void checkDelete(Delete dt)
	{
		//two identical delete sentences are not allowed  
		
		//
		var  List<Delete> allExistedDeleteSentence =changeIteratorIntoList(dt.eContainer.eAllContents.filter(Delete))
		

        var identicalNumber =0  //How many identical delete sentences?
        for(var i =0;i<allExistedDeleteSentence.size;i++)
        {
        	//if table name is equal
        	if(dt.table.name.equals(allExistedDeleteSentence.get(i).table.name))
        	   {
        	   	//if condition number is equal?
        	   	 if(dt.deletecondition.size.equals(allExistedDeleteSentence.get(i).deletecondition.size))
        	   	 {
        	   	 	var indicator=0 // used for judging if there is one identical record
        	   	 	for(var j=0;j<dt.deletecondition.size;j++)
        	   	 	{
        	   	 		if(dt.deletecondition.get(j).attribute.equals(allExistedDeleteSentence.get(i).deletecondition.get(j).attribute)) 
        	   	 		  {
        	   	 		  	if(dt.deletecondition.get(j).operator.equals(allExistedDeleteSentence.get(i).deletecondition.get(j).operator))
        	   	 		  	 {
        	   	 		  	 	 if(cutting(dt.deletecondition.get(j).value.toString).equals(cutting(allExistedDeleteSentence.get(i).deletecondition.get(j).value.toString)))
        	   	 		  	 	 	indicator++        	   	 		  	 	 
        	   	 		  	 }
        	   	 		  }	   	 		   
        	   	 	}
        	   	 	if(indicator.equals(dt.deletecondition.size)) //if all conditions in a delete setence is equal to dt's conditions 
        	   	 	 identicalNumber++
        	   	 	
        	   	 }
        	   }
        }
        if(identicalNumber!=1)
        warning("Cannot perform two identical delete operation!",dt,EasySqlPackage.Literals.DELETE__DELETECONDITION, INVALID_DUPLICATE_DELETE)
	}
	
	//focus on checking if the set value in update operation is empty
	@Check
	def void chekUpdateSetNotNull(Update ud)
	{
		if(ud.modification.empty)
		   warning("the content in Update() cannot be empty!", ud,
				EasySqlPackage.Literals.UPDATE__MODIFICATION, INVALID_SETVALUE_NOTNULL_UNDATE)
	}
	
	//focus on checking if some input in join query operation can be empty or not
	@Check
	def void JoinTableNotEmpty(JoinQuery jq)
	{
		if(jq.jattributes.empty)
		warning("the content in Joinsearch() cannot be empty!", jq,
				EasySqlPackage.Literals.JOIN_QUERY__JATTRIBUTES, INVALID_ATTRIBUTE_NOTNULL_JOIN_TABLE)
	    
	    if(jq.joincondition.empty)
		warning("the content in On() cannot be empty!", jq,
				EasySqlPackage.Literals.JOIN_QUERY__JOINCONDITION, INVALID_CONDITION_NOTNULL_JOIN_TABLE)	    
	}
    
    //focus on checking if some input in sub-query can be empty or not
    @Check
    def void SubSearchWhenNotEmpty(NestedQuery nq)
    {
    	if(nq.nattributes1.empty)
    	warning("the content in When() cannot be empty!", nq,
				EasySqlPackage.Literals.NESTED_QUERY__NATTRIBUTES1, INVALID_WHEN_NOTNULL_SUBSEARCH)
    }
    
    
    
    
    
    
	//convert from iterator into list
	def  <Delete> List<Delete> changeIteratorIntoList(Iterator<Delete> iter) 
	{
       var List<Delete> copy = newArrayList() 
        while (iter.hasNext())
       copy.add(iter.next());
       return copy;
    }

	def String cutting(String a)
	{
		var begin = a.indexOf(":")+2
		var end = a.indexOf(")")
		var result = a.substring(begin,end)
		return result
	}
    
    def getAllRepeatElements(  List<String> originalTableName)
    {
    	  var List<String> allRepeatTableName = newArrayList() 
    	  var loopSize =originalTableName.size   	  
    	  for(var indexA=0;indexA< loopSize;indexA++)
        {
        	var a = originalTableName.get(indexA) 
        	for(var indexB=(indexA+1);indexB<loopSize;indexB++)
        	{
        		var b =originalTableName.get(indexB)
        		if(a==b)
        		{
        			if(!allRepeatTableName.contains(a))      		  
        			 allRepeatTableName.add(a)
        		}     		
        	}
        }
  	  return allRepeatTableName
    }
}
